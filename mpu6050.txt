#include "stm32f4xx.h"
#include <math.h>
#define MPU6050_ADDR 0x68 << 1 // 7-bit address shifted for HAL I2C
float pitch;
volatile uint32_t msTicks;
void SysTick_Handler(void) { msTicks++; }
void Delay_ms(uint32_t ms) {
    uint32_t start = msTicks;
    while ((msTicks - start) < ms);
}

// I2C1 init: PB6 = SCL, PB7 = SDA, 100kHz standard mode
void I2C1_Init(void) {
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;

    // Configure PB6, PB7 as AF4 open-drain with pull-up
    GPIOB->MODER &= ~((3 << 12) | (3 << 14)); // Clear mode bits (PB6,7)
    GPIOB->MODER |= (2 << 12) | (2 << 14); // AF mode
    GPIOB->OTYPER |= (1 << 6) | (1 << 7); // open-drain
    GPIOB->OSPEEDR |= (3 << 12) | (3 << 14); // very high speed
    GPIOB->PUPDR &= ~((3 << 12) | (3 << 14));
    GPIOB->PUPDR |= (1 << 12) | (1 << 14); // pull-up
    GPIOB->AFR[0] |= (4 << 24) | (4 << 28); // AF4 for I2C1

    // Reset I2C1
    I2C1->CR1 |= I2C_CR1_SWRST;
    I2C1->CR1 &= ~I2C_CR1_SWRST;

    // Configure I2C1 clock
    I2C1->CR2 = 16;  // APB1 clk 16 MHz
    I2C1->CCR = 80;  // 100kHz standard mode
    I2C1->TRISE = 17;

    I2C1->CR1 |= I2C_CR1_PE; // enable I2C1
}

// Basic I2C write to MPU6050 register
void I2C1_WriteReg(uint8_t reg, uint8_t data) {
    while (I2C1->SR2 & I2C_SR2_BUSY);
    I2C1->CR1 |= I2C_CR1_START;
    while (!(I2C1->SR1 & I2C_SR1_SB));

    I2C1->DR = MPU6050_ADDR & ~1;
    while (!(I2C1->SR1 & I2C_SR1_ADDR));
    (void)I2C1->SR2;

    I2C1->DR = reg;
    while (!(I2C1->SR1 & I2C_SR1_TXE));

    I2C1->DR = data;
    while (!(I2C1->SR1 & I2C_SR1_TXE));

    I2C1->CR1 |= I2C_CR1_STOP;
}

// Basic I2C read from MPU6050 register
uint8_t I2C1_ReadReg(uint8_t reg) {
    while (I2C1->SR2 & I2C_SR2_BUSY);
    I2C1->CR1 |= I2C_CR1_START;
    while (!(I2C1->SR1 & I2C_SR1_SB));

    I2C1->DR = MPU6050_ADDR & ~1;
    while (!(I2C1->SR1 & I2C_SR1_ADDR));
    (void)I2C1->SR2;

    I2C1->DR = reg;
    while (!(I2C1->SR1 & I2C_SR1_TXE));

    I2C1->CR1 |= I2C_CR1_START;
    while (!(I2C1->SR1 & I2C_SR1_SB));

    I2C1->DR = MPU6050_ADDR | 1;
    while (!(I2C1->SR1 & I2C_SR1_ADDR));
    (void)I2C1->SR2;

    I2C1->CR1 &= ~I2C_CR1_ACK;
    I2C1->CR1 |= I2C_CR1_STOP;

    while (!(I2C1->SR1 & I2C_SR1_RXNE));
    uint8_t val = I2C1->DR;
    return val;
}

// Read 16-bit sensor data (high + low)
int16_t MPU6050_Read16(uint8_t reg) {
    uint8_t high = I2C1_ReadReg(reg);
    uint8_t low = I2C1_ReadReg(reg + 1);
    return (int16_t)((high << 8) | low);
}

// MPU6050 init
void MPU6050_Init(void) {
    I2C1_WriteReg(0x6B, 0x00); // wake up MPU6050
    I2C1_WriteReg(0x1B, 0x00); // gyro full scale ±250 dps
    I2C1_WriteReg(0x1C, 0x00); // accel full scale ±2g
}

// Calculate pitch from accel raw values
float Calculate_Pitch(int16_t ax, int16_t ay, int16_t az) {
    float x = (float)ax;
    float y = (float)ay;
    float z = (float)az;
    float pitch = atan2(x, sqrt(y*y + z*z)) * 180 / 3.14159265f;
    return pitch;
}

int main(void) {
    SysTick->LOAD = 16000 - 1;
    SysTick->VAL = 0;
    SysTick->CTRL = 7;  // enable with interrupt and processor clock

    I2C1_Init();
    MPU6050_Init();

    while (1) {
        int16_t ax = MPU6050_Read16(0x3B);
        int16_t ay = MPU6050_Read16(0x3D);
        int16_t az = MPU6050_Read16(0x3F);

        int16_t gx = MPU6050_Read16(0x43);
        int16_t gy = MPU6050_Read16(0x45);
        int16_t gz = MPU6050_Read16(0x47);

        pitch = Calculate_Pitch(ax, ay, az);

        // Highlight pitch (in degrees)
        // Use pitch for control or monitoring as needed

        Delay_ms(100);
    }
}
